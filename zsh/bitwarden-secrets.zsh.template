# Bitwarden Secrets Loader for Shell and Claude Code
# Automatically unlocks Bitwarden vault and loads API keys as environment variables
# Uses macOS Keychain for secure password storage

# Function to safely load secrets from Bitwarden
bw_load_secrets() {
    # Suppress any debug output from variable assignments
    emulate -L zsh
    setopt LOCAL_OPTIONS NO_XTRACE NO_VERBOSE
    unsetopt XTRACE VERBOSE
    # Check if bw CLI is installed
    if ! command -v bw &> /dev/null; then
        echo "Warning: Bitwarden CLI not found. Secrets not loaded." >&2
        echo "Install with: brew install bitwarden-cli" >&2
        echo "Or run setup: ~/.dotfiles/.scripts/setup_bitwarden.sh" >&2
        return 1
    fi

    # Check if already unlocked by testing if we can list items
    if [ -n "$BW_SESSION" ]; then
        local validation_result
        validation_result=$(bw list items --session "$BW_SESSION" 2>&1)
        local validation_status=$?

        if [ $validation_status -eq 0 ]; then
            # Session is valid, load secrets
            if _bw_export_secrets; then
                return 0
            else
                echo "Error: Failed to export secrets despite valid session" >&2
                return 1
            fi
        else
            # Session invalid or expired
            [ -n "$BW_DEBUG" ] && echo "Info: Bitwarden session expired, re-authenticating..." >&2
            unset BW_SESSION
            # Fall through to unlock logic below
        fi
    fi

    # Try to unlock vault using password from macOS Keychain
    # SECURITY: Never export password - use local variable only
    local bw_password
    bw_password=$(security find-generic-password -a "$USER" -s "Bitwarden CLI" -w 2>/dev/null)

    if [ -z "$bw_password" ]; then
        # Password not in Keychain - provide guidance
        if ! security find-generic-password -a "$USER" -s "Bitwarden CLI" &> /dev/null; then
            # Password was never stored - this is expected on first run
            [ -n "$BW_DEBUG" ] && echo "Info: Bitwarden password not in Keychain. Auto-unlock disabled." >&2
            [ -n "$BW_DEBUG" ] && echo "To enable: ~/.dotfiles/.scripts/setup_bitwarden.sh" >&2
        else
            # Password exists but couldn't be retrieved - this is an error
            echo "Error: Failed to retrieve Bitwarden password from Keychain" >&2
        fi
        return 1
    fi

    # Unlock vault using password env var (never exported to global environment)
    local session_key
    local unlock_error
    unlock_error=$(BW_PASSWORD="$bw_password" bw unlock --passwordenv BW_PASSWORD --raw 2>&1)
    local unlock_status=$?

    # Clear password from memory immediately
    unset bw_password

    if [ $unlock_status -eq 0 ] && [ -n "$unlock_error" ]; then
        session_key="$unlock_error"
        export BW_SESSION="$session_key"
        if ! _bw_export_secrets; then
            echo "Error: Failed to export secrets from Bitwarden vault" >&2
            echo "Check the error messages above for details" >&2
            return 1
        fi
        return 0
    else
        echo "Error: Failed to unlock Bitwarden vault" >&2
        if echo "$unlock_error" | grep -q "Invalid master password"; then
            echo "The password in macOS Keychain appears to be incorrect" >&2
            echo "Update it by running: ~/.dotfiles/.scripts/setup_bitwarden.sh" >&2
        elif echo "$unlock_error" | grep -q "Two-step"; then
            echo "Your vault requires two-factor authentication" >&2
            echo "Manually unlock with: bw unlock" >&2
        else
            echo "Try manually: bw unlock" >&2
        fi
        return 1
    fi
}

# Helper function to export secrets as environment variables
_bw_export_secrets() {
    # Check if jq is available for JSON parsing
    if ! command -v jq &> /dev/null; then
        echo "Error: jq not installed. Install with: brew install jq" >&2
        return 1
    fi

    # Track what we find for reporting
    local -a missing_notes=()
    local -a found_notes=()
    local secrets_loaded=0

    # Configuration: Bitwarden folder ID containing secret notes
    # This avoids ambiguity when item names match other vault entries
    # To find your folder ID: bw list folders | jq '.[] | {name, id}'
    # Create a folder like "CLI" or "Secrets" in Bitwarden and put your notes there
    local secrets_folder_id="YOUR_FOLDER_ID_HERE"  # Replace with your folder ID

    # Configuration: List of Bitwarden secure note names to load secrets from
    # Notes must be in the folder specified above
    # Each note can contain multiple hidden fields
    # Hidden field name = environment variable name
    # Hidden field value = secret value
    local secret_notes=(
        "Claude"      # For Claude Code and MCP server secrets
        # Add more note names here as needed:
        # "AWS"       # For AWS credentials
        # "GitHub"    # For GitHub tokens
        # "DevOps"    # For various DevOps tools
    )

    # Process each configured note
    for note_name in "${secret_notes[@]}"; do
        # Skip if note name starts with # (comment)
        if [[ "$note_name" =~ ^# ]]; then
            continue
        fi

        # Get the note item from Bitwarden using folder + type filtering
        # This avoids ambiguity when multiple items contain the search term
        local item_json
        item_json=$(bw list items --folderid "$secrets_folder_id" --search "$note_name" --session "$BW_SESSION" 2>/dev/null | jq -r '[.[] | select(.type == 2)] | first' 2>/dev/null)

        if [ -z "$item_json" ] || [ "$item_json" = "null" ]; then
            # Note doesn't exist in folder - track it
            missing_notes+=("$note_name")
            continue
        fi

        found_notes+=("$note_name")

        # Get all hidden fields (type=1) from this note
        # Use here-strings to avoid subshell issues
        # Get field count with error checking
        local field_count
        local jq_error
        field_count=$(jq -r '[.fields[]? | select(.type==1)] | length' <<< "$item_json" 2>&1)
        local jq_status=$?

        if [ $jq_status -ne 0 ]; then
            echo "Error: Failed to parse Bitwarden note '$note_name'" >&2
            echo "jq error: $field_count" >&2
            continue
        fi

        # Validate field_count is a number
        if ! [[ "$field_count" =~ ^[0-9]+$ ]]; then
            echo "Error: Invalid field count from note '$note_name': $field_count" >&2
            continue
        fi

        if [ -z "$field_count" ] || [ "$field_count" = "0" ]; then
            # No hidden fields in this note
            echo "Warning: Note '$note_name' has no hidden fields" >&2
            echo "Ensure you're using 'Hidden' field type (not 'Text') in Bitwarden" >&2
            continue
        fi

        # Process each hidden field by index
        for ((i=0; i<field_count; i++)); do
            # Get field name and value for this index (combined to avoid trace output)
            local env_var_name=$(jq -r "[.fields[]? | select(.type==1)][$i].name" <<< "$item_json" 2>/dev/null)
            local secret_value=$(jq -r "[.fields[]? | select(.type==1)][$i].value" <<< "$item_json" 2>/dev/null)

            # SECURITY: Validate env var name to prevent command injection
            # Valid names must start with letter/underscore and contain only alphanumeric/underscores
            if ! [[ "$env_var_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                echo "Warning: Skipping invalid environment variable name '$env_var_name' in note '$note_name'" >&2
                echo "Names must start with letter/underscore and contain only alphanumeric/underscores" >&2
                continue
            fi

            # Skip if env var name or value is invalid
            if [ -z "$env_var_name" ] || [ "$env_var_name" = "null" ]; then
                continue
            fi

            if [ -z "$secret_value" ] || [ "$secret_value" = "null" ]; then
                continue
            fi

            # Skip if already set (don't override existing values)
            if [ -n "${(P)env_var_name}" ]; then
                continue
            fi

            # Export the environment variable
            export "$env_var_name"="$secret_value"
            ((secrets_loaded++))
        done
    done

    # Report summary
    if [ ${#missing_notes[@]} -gt 0 ]; then
        echo "Warning: Bitwarden notes not found: ${missing_notes[*]}" >&2
        echo "Check your vault at: https://vault.bitwarden.com" >&2
    fi

    if [ $secrets_loaded -eq 0 ] && [ ${#found_notes[@]} -gt 0 ]; then
        echo "Warning: Found notes but loaded 0 secrets" >&2
        echo "Notes found: ${found_notes[*]}" >&2
        echo "Check that notes have hidden fields (type=1)" >&2
    fi

    [ -n "$BW_DEBUG" ] && [ $secrets_loaded -gt 0 ] && echo "Loaded $secrets_loaded secrets from ${#found_notes[@]} notes" >&2

    # Return success only if we loaded at least one secret (when notes are configured)
    if [ ${#found_notes[@]} -gt 0 ] || [ ${#missing_notes[@]} -gt 0 ]; then
        # User has configured notes, we should have loaded something
        [ $secrets_loaded -gt 0 ] && return 0 || return 1
    else
        # No notes configured - this is okay
        return 0
    fi
}

# Load secrets on shell startup
bw_load_secrets

# Reload secrets from Bitwarden
bw-reload() {
    if bw_load_secrets; then
        echo "✓ Bitwarden secrets reloaded"
        return 0
    else
        echo "✗ Failed to reload secrets" >&2
        return 1
    fi
}

# Lock vault and clear session
bw-lock() {
    if bw lock; then
        unset BW_SESSION
        echo "✓ Bitwarden vault locked"
        return 0
    else
        echo "✗ Failed to lock vault" >&2
        return 1
    fi
}
